'use strict';

var web3_js = require('@solana/web3.js');
var splToken = require('@solana/spl-token');
var types = require('x402/types');
var zod = require('zod');

// src/utils/helpers.ts
function createPaymentHeaderFromTransaction(transaction, paymentRequirements, x402Version) {
  const serializedTransaction = Buffer.from(transaction.serialize()).toString("base64");
  const paymentPayload = {
    x402Version,
    scheme: paymentRequirements.scheme,
    network: paymentRequirements.network,
    payload: {
      transaction: serializedTransaction
    }
  };
  const paymentHeader = Buffer.from(JSON.stringify(paymentPayload)).toString("base64");
  return paymentHeader;
}
function getDefaultRpcUrl(network) {
  if (network === "solana") {
    return "https://api.mainnet-beta.solana.com";
  } else if (network === "solana-devnet") {
    return "https://api.devnet.solana.com";
  }
  throw new Error(`Unexpected network: ${network}`);
}
function getDefaultTokenAsset(network) {
  if (network === "solana") {
    return {
      address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      decimals: 6
    };
  } else if (network === "solana-devnet") {
    return {
      address: "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
      decimals: 6
    };
  }
  throw new Error(`Unexpected network: ${network}`);
}
function toAtomicUnits(amount, decimals) {
  return BigInt(Math.floor(amount * Math.pow(10, decimals)));
}
function fromAtomicUnits(atomicUnits, decimals) {
  return Number(atomicUnits) / Math.pow(10, decimals);
}
function usdToMicroUsdc(usdAmount) {
  return Math.floor(usdAmount * 1e6);
}
function microUsdcToUsd(microUsdc) {
  return microUsdc / 1e6;
}
async function createSolanaPaymentHeader(wallet, x402Version, paymentRequirements, rpcUrl) {
  const connection = new web3_js.Connection(rpcUrl, "confirmed");
  const feePayer = paymentRequirements?.extra?.feePayer;
  if (typeof feePayer !== "string" || !feePayer) {
    throw new Error("Missing facilitator feePayer in payment requirements (extra.feePayer).");
  }
  const feePayerPubkey = new web3_js.PublicKey(feePayer);
  const walletAddress = wallet?.publicKey?.toString() || wallet?.address;
  if (!walletAddress) {
    throw new Error("Missing connected Solana wallet address or publicKey");
  }
  const userPubkey = new web3_js.PublicKey(walletAddress);
  if (!paymentRequirements?.payTo) {
    throw new Error("Missing payTo in payment requirements");
  }
  const destination = new web3_js.PublicKey(paymentRequirements.payTo);
  const instructions = [];
  instructions.push(
    web3_js.ComputeBudgetProgram.setComputeUnitLimit({
      units: 7e3
      // Sufficient for SPL token transfer
    })
  );
  instructions.push(
    web3_js.ComputeBudgetProgram.setComputeUnitPrice({
      microLamports: 1
      // Minimal price
    })
  );
  if (!paymentRequirements.asset) {
    throw new Error("Missing token mint for SPL transfer");
  }
  const mintPubkey = new web3_js.PublicKey(paymentRequirements.asset);
  const mintInfo = await connection.getAccountInfo(mintPubkey, "confirmed");
  const programId = mintInfo?.owner?.toBase58() === splToken.TOKEN_2022_PROGRAM_ID.toBase58() ? splToken.TOKEN_2022_PROGRAM_ID : splToken.TOKEN_PROGRAM_ID;
  const mint = await splToken.getMint(connection, mintPubkey, void 0, programId);
  const sourceAta = await splToken.getAssociatedTokenAddress(
    mintPubkey,
    userPubkey,
    false,
    programId
  );
  const destinationAta = await splToken.getAssociatedTokenAddress(
    mintPubkey,
    destination,
    false,
    programId
  );
  const sourceAtaInfo = await connection.getAccountInfo(sourceAta, "confirmed");
  if (!sourceAtaInfo) {
    throw new Error(
      `User does not have an Associated Token Account for ${paymentRequirements.asset}. Please create one first or ensure you have the required token.`
    );
  }
  const destAtaInfo = await connection.getAccountInfo(destinationAta, "confirmed");
  if (!destAtaInfo) {
    throw new Error(
      `Destination does not have an Associated Token Account for ${paymentRequirements.asset}. The receiver must create their token account before receiving payments.`
    );
  }
  const amount = BigInt(paymentRequirements.maxAmountRequired);
  instructions.push(
    splToken.createTransferCheckedInstruction(
      sourceAta,
      mintPubkey,
      destinationAta,
      userPubkey,
      amount,
      mint.decimals,
      [],
      programId
    )
  );
  const { blockhash } = await connection.getLatestBlockhash("confirmed");
  const message = new web3_js.TransactionMessage({
    payerKey: feePayerPubkey,
    recentBlockhash: blockhash,
    instructions
  }).compileToV0Message();
  const transaction = new web3_js.VersionedTransaction(message);
  if (typeof wallet?.signTransaction !== "function") {
    throw new Error("Connected wallet does not support signTransaction");
  }
  const userSignedTx = await wallet.signTransaction(transaction);
  return createPaymentHeaderFromTransaction(
    userSignedTx,
    paymentRequirements,
    x402Version
  );
}

// src/client/payment-interceptor.ts
function createPaymentFetch(fetchFn, wallet, rpcUrl, maxValue = BigInt(0)) {
  return async (input, init) => {
    const response = await fetchFn(input, init);
    if (response.status !== 402) {
      return response;
    }
    const rawResponse = await response.json();
    const x402Version = rawResponse.x402Version;
    const parsedPaymentRequirements = rawResponse.accepts || [];
    const selectedRequirements = parsedPaymentRequirements.find(
      (req) => req.scheme === "exact" && (req.network === "solana-devnet" || req.network === "solana")
    );
    if (!selectedRequirements) {
      console.error(
        "\u274C No suitable Solana payment requirements found. Available networks:",
        parsedPaymentRequirements.map((req) => req.network)
      );
      throw new Error("No suitable Solana payment requirements found");
    }
    if (maxValue > BigInt(0) && BigInt(selectedRequirements.maxAmountRequired) > maxValue) {
      throw new Error("Payment amount exceeds maximum allowed");
    }
    const paymentHeader = await createSolanaPaymentHeader(
      wallet,
      x402Version,
      selectedRequirements,
      rpcUrl
    );
    const newInit = {
      ...init,
      headers: {
        ...init?.headers || {},
        "X-PAYMENT": paymentHeader,
        "Access-Control-Expose-Headers": "X-PAYMENT-RESPONSE"
      }
    };
    return await fetchFn(input, newInit);
  };
}

// src/client/index.ts
var X402Client = class {
  paymentFetch;
  constructor(config) {
    const rpcUrl = config.rpcUrl || getDefaultRpcUrl(config.network);
    const fetchFn = config.customFetch || globalThis.fetch.bind(globalThis);
    this.paymentFetch = createPaymentFetch(
      fetchFn,
      config.wallet,
      rpcUrl,
      config.maxPaymentAmount || BigInt(0)
    );
  }
  /**
   * Make a fetch request with automatic x402 payment handling.
   * If a customFetch was provided in the config, it will be used for all requests.
   */
  async fetch(input, init) {
    return this.paymentFetch(input, init);
  }
};
function createX402Client(config) {
  return new X402Client(config);
}

// src/server/facilitator-client.ts
var FacilitatorClient = class {
  constructor(facilitatorUrl) {
    this.facilitatorUrl = facilitatorUrl;
  }
  /**
   * Get fee payer address from facilitator's /supported endpoint
   */
  async getFeePayer(network) {
    const response = await fetch(`${this.facilitatorUrl}/supported`);
    if (!response.ok) {
      throw new Error(`Facilitator /supported returned ${response.status}`);
    }
    const supportedData = await response.json();
    const networkSupport = supportedData.kinds?.find(
      (kind) => kind.network === network && kind.scheme === "exact"
    );
    if (!networkSupport?.extra?.feePayer) {
      throw new Error(
        `Facilitator does not support network "${network}" with scheme "exact" or feePayer not provided`
      );
    }
    return networkSupport.extra.feePayer;
  }
  /**
   * Verify payment with facilitator
   * @returns VerifyResponse with isValid and optional invalidReason from facilitator
   */
  async verifyPayment(paymentHeader, paymentRequirements) {
    try {
      const paymentPayload = JSON.parse(
        Buffer.from(paymentHeader, "base64").toString("utf8")
      );
      const verifyPayload = {
        paymentPayload,
        paymentRequirements
      };
      const response = await fetch(`${this.facilitatorUrl}/verify`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(verifyPayload)
      });
      if (!response.ok) {
        const errorBody = await response.text();
        console.error(`Facilitator /verify returned ${response.status}:`, errorBody);
        return {
          isValid: false,
          invalidReason: "unexpected_verify_error"
        };
      }
      const facilitatorResponse = await response.json();
      return facilitatorResponse;
    } catch (error) {
      console.error("Payment verification failed:", error);
      return {
        isValid: false,
        invalidReason: "unexpected_verify_error"
      };
    }
  }
  /**
   * Settle payment with facilitator
   * @returns SettleResponse with success status and optional errorReason from facilitator
   */
  async settlePayment(paymentHeader, paymentRequirements) {
    try {
      const paymentPayload = JSON.parse(
        Buffer.from(paymentHeader, "base64").toString("utf8")
      );
      const settlePayload = {
        paymentPayload,
        paymentRequirements
      };
      const response = await fetch(`${this.facilitatorUrl}/settle`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(settlePayload)
      });
      if (!response.ok) {
        const errorBody = await response.text();
        console.error(`Facilitator /settle returned ${response.status}:`, errorBody);
        return {
          success: false,
          errorReason: "unexpected_settle_error",
          transaction: "",
          network: paymentRequirements.network
        };
      }
      const facilitatorResponse = await response.json();
      return facilitatorResponse;
    } catch (error) {
      console.error("Payment settlement failed:", error);
      return {
        success: false,
        errorReason: "unexpected_settle_error",
        transaction: "",
        network: paymentRequirements.network
      };
    }
  }
};

// src/server/payment-handler.ts
var X402PaymentHandler = class {
  facilitatorClient;
  config;
  constructor(config) {
    const defaultToken = getDefaultTokenAsset(config.network);
    this.config = {
      network: config.network,
      treasuryAddress: config.treasuryAddress,
      facilitatorUrl: config.facilitatorUrl,
      rpcUrl: config.rpcUrl || getDefaultRpcUrl(config.network),
      defaultToken: config.defaultToken || defaultToken,
      middlewareConfig: config.middlewareConfig
    };
    this.facilitatorClient = new FacilitatorClient(config.facilitatorUrl);
  }
  /**
   * Extract payment header from request headers
   * Pass in headers object from any framework (Next.js, Express, etc.)
   */
  extractPayment(headers) {
    if (headers instanceof Headers) {
      return headers.get("X-PAYMENT") || headers.get("x-payment");
    }
    const xPayment = headers["X-PAYMENT"] || headers["x-payment"];
    return Array.isArray(xPayment) ? xPayment[0] || null : xPayment || null;
  }
  /**
   * Create payment requirements object from x402 RouteConfig
   * @param routeConfig - x402 standard RouteConfig (price, network, config)
   * @param resource - Optional resource URL override (uses config.resource if not provided)
   */
  async createPaymentRequirements(routeConfig, resource) {
    const feePayer = await this.facilitatorClient.getFeePayer(this.config.network);
    const price = routeConfig.price;
    const config = { ...this.config.middlewareConfig, ...routeConfig.config };
    const finalResource = resource || config.resource;
    if (!finalResource) {
      throw new Error("resource is required: provide either as parameter or in RouteConfig.config.resource");
    }
    const paymentRequirements = {
      scheme: "exact",
      network: routeConfig.network,
      maxAmountRequired: price.amount,
      resource: finalResource,
      description: config.description || "Payment required",
      mimeType: config.mimeType || "application/json",
      payTo: this.config.treasuryAddress,
      maxTimeoutSeconds: config.maxTimeoutSeconds || 300,
      asset: price.asset.address,
      outputSchema: config.outputSchema || {},
      extra: {
        feePayer
      }
    };
    return paymentRequirements;
  }
  /**
   * Create a 402 Payment Required response body
   * Use this with your framework's response method
   * @param requirements - Payment requirements (from createPaymentRequirements)
   */
  create402Response(requirements) {
    return {
      status: 402,
      body: {
        x402Version: 1,
        accepts: [requirements],
        error: "Payment required"
      }
    };
  }
  /**
   * Verify payment with facilitator
   * @returns VerifyResponse with isValid and optional invalidReason
   */
  async verifyPayment(paymentHeader, paymentRequirements) {
    return this.facilitatorClient.verifyPayment(paymentHeader, paymentRequirements);
  }
  /**
   * Settle payment with facilitator
   * @returns SettleResponse with success status and optional errorReason
   */
  async settlePayment(paymentHeader, paymentRequirements) {
    return this.facilitatorClient.settlePayment(paymentHeader, paymentRequirements);
  }
};
var SolanaNetworkSchema = zod.z.enum([
  "solana-devnet",
  "solana"
]);
var SolanaPaymentPayloadSchema = zod.z.object({
  x402Version: zod.z.literal(1),
  scheme: zod.z.literal("exact"),
  network: SolanaNetworkSchema,
  payload: types.ExactSvmPayloadSchema
  // Official SVM payload from x402
});

// src/types/solana-payment.ts
function isSolanaNetwork(network) {
  return network === "solana" || network === "solana-devnet";
}

Object.defineProperty(exports, "ExactSvmPayloadSchema", {
  enumerable: true,
  get: function () { return types.ExactSvmPayloadSchema; }
});
Object.defineProperty(exports, "PaymentRequirementsSchema", {
  enumerable: true,
  get: function () { return types.PaymentRequirementsSchema; }
});
Object.defineProperty(exports, "SettleResponseSchema", {
  enumerable: true,
  get: function () { return types.SettleResponseSchema; }
});
Object.defineProperty(exports, "SupportedPaymentKindSchema", {
  enumerable: true,
  get: function () { return types.SupportedPaymentKindSchema; }
});
Object.defineProperty(exports, "SupportedPaymentKindsResponseSchema", {
  enumerable: true,
  get: function () { return types.SupportedPaymentKindsResponseSchema; }
});
Object.defineProperty(exports, "SupportedSVMNetworks", {
  enumerable: true,
  get: function () { return types.SupportedSVMNetworks; }
});
Object.defineProperty(exports, "SvmNetworkToChainId", {
  enumerable: true,
  get: function () { return types.SvmNetworkToChainId; }
});
Object.defineProperty(exports, "VerifyResponseSchema", {
  enumerable: true,
  get: function () { return types.VerifyResponseSchema; }
});
Object.defineProperty(exports, "x402ResponseSchema", {
  enumerable: true,
  get: function () { return types.x402ResponseSchema; }
});
exports.FacilitatorClient = FacilitatorClient;
exports.SolanaNetworkSchema = SolanaNetworkSchema;
exports.SolanaPaymentPayloadSchema = SolanaPaymentPayloadSchema;
exports.X402Client = X402Client;
exports.X402PaymentHandler = X402PaymentHandler;
exports.createPaymentHeaderFromTransaction = createPaymentHeaderFromTransaction;
exports.createX402Client = createX402Client;
exports.fromAtomicUnits = fromAtomicUnits;
exports.getDefaultRpcUrl = getDefaultRpcUrl;
exports.getDefaultTokenAsset = getDefaultTokenAsset;
exports.isSolanaNetwork = isSolanaNetwork;
exports.microUsdcToUsd = microUsdcToUsd;
exports.toAtomicUnits = toAtomicUnits;
exports.usdToMicroUsdc = usdToMicroUsdc;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map