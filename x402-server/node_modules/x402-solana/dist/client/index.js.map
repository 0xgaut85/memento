{"version":3,"sources":["../../src/utils/helpers.ts","../../src/client/transaction-builder.ts","../../src/client/payment-interceptor.ts","../../src/client/index.ts"],"names":["Connection","PublicKey","ComputeBudgetProgram","TOKEN_2022_PROGRAM_ID","TOKEN_PROGRAM_ID","getMint","getAssociatedTokenAddress","createTransferCheckedInstruction","TransactionMessage","VersionedTransaction"],"mappings":";;;;;;AAWO,SAAS,kCAAA,CACd,WAAA,EACA,mBAAA,EACA,WAAA,EACQ;AAER,EAAA,MAAM,qBAAA,GAAwB,OAAO,IAAA,CAAK,WAAA,CAAY,WAAW,CAAA,CAAE,SAAS,QAAQ,CAAA;AAGpF,EAAA,MAAM,cAAA,GAAiB;AAAA,IACrB,WAAA;AAAA,IACA,QAAQ,mBAAA,CAAoB,MAAA;AAAA,IAC5B,SAAS,mBAAA,CAAoB,OAAA;AAAA,IAC7B,OAAA,EAAS;AAAA,MACP,WAAA,EAAa;AAAA;AACf,GACF;AAGA,EAAA,MAAM,aAAA,GAAgB,OAAO,IAAA,CAAK,IAAA,CAAK,UAAU,cAAc,CAAC,CAAA,CAAE,QAAA,CAAS,QAAQ,CAAA;AAEnF,EAAA,OAAO,aAAA;AACT;AAOO,SAAS,iBAAiB,OAAA,EAAgC;AAC/D,EAAA,IAAI,YAAY,QAAA,EAAU;AACxB,IAAA,OAAO,qCAAA;AAAA,EACT,CAAA,MAAA,IAAW,YAAY,eAAA,EAAiB;AACtC,IAAA,OAAO,+BAAA;AAAA,EACT;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,CAAA,oBAAA,EAAuB,OAAO,CAAA,CAAE,CAAA;AAClD;AC3BA,eAAsB,yBAAA,CACpB,MAAA,EACA,WAAA,EACA,mBAAA,EACA,MAAA,EACiB;AACjB,EAAA,MAAM,UAAA,GAAa,IAAIA,kBAAA,CAAW,MAAA,EAAQ,WAAW,CAAA;AAGrD,EAAA,MAAM,QAAA,GAAY,qBAA2D,KAAA,EAAO,QAAA;AACpF,EAAA,IAAI,OAAO,QAAA,KAAa,QAAA,IAAY,CAAC,QAAA,EAAU;AAC7C,IAAA,MAAM,IAAI,MAAM,wEAAwE,CAAA;AAAA,EAC1F;AACA,EAAA,MAAM,cAAA,GAAiB,IAAIC,iBAAA,CAAU,QAAQ,CAAA;AAG7C,EAAA,MAAM,aAAA,GAAgB,MAAA,EAAQ,SAAA,EAAW,QAAA,MAAc,MAAA,EAAQ,OAAA;AAC/D,EAAA,IAAI,CAAC,aAAA,EAAe;AAClB,IAAA,MAAM,IAAI,MAAM,sDAAsD,CAAA;AAAA,EACxE;AACA,EAAA,MAAM,UAAA,GAAa,IAAIA,iBAAA,CAAU,aAAa,CAAA;AAE9C,EAAA,IAAI,CAAC,qBAAqB,KAAA,EAAO;AAC/B,IAAA,MAAM,IAAI,MAAM,uCAAuC,CAAA;AAAA,EACzD;AACA,EAAA,MAAM,WAAA,GAAc,IAAIA,iBAAA,CAAU,mBAAA,CAAoB,KAAK,CAAA;AAE3D,EAAA,MAAM,eAAyC,EAAC;AAGhD,EAAA,YAAA,CAAa,IAAA;AAAA,IACXC,6BAAqB,mBAAA,CAAoB;AAAA,MACvC,KAAA,EAAO;AAAA;AAAA,KACR;AAAA,GACH;AAEA,EAAA,YAAA,CAAa,IAAA;AAAA,IACXA,6BAAqB,mBAAA,CAAoB;AAAA,MACvC,aAAA,EAAe;AAAA;AAAA,KAChB;AAAA,GACH;AAGA,EAAA,IAAI,CAAC,oBAAoB,KAAA,EAAO;AAC9B,IAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,EACvD;AACA,EAAA,MAAM,UAAA,GAAa,IAAID,iBAAA,CAAU,mBAAA,CAAoB,KAAe,CAAA;AAGpE,EAAA,MAAM,QAAA,GAAW,MAAM,UAAA,CAAW,cAAA,CAAe,YAAY,WAAW,CAAA;AACxE,EAAA,MAAM,SAAA,GACJ,UAAU,KAAA,EAAO,QAAA,OAAeE,8BAAA,CAAsB,QAAA,KAClDA,8BAAA,GACAC,yBAAA;AAGN,EAAA,MAAM,OAAO,MAAMC,gBAAA,CAAQ,UAAA,EAAY,UAAA,EAAY,QAAW,SAAS,CAAA;AAGvE,EAAA,MAAM,YAAY,MAAMC,kCAAA;AAAA,IACtB,UAAA;AAAA,IACA,UAAA;AAAA,IACA,KAAA;AAAA,IACA;AAAA,GACF;AACA,EAAA,MAAM,iBAAiB,MAAMA,kCAAA;AAAA,IAC3B,UAAA;AAAA,IACA,WAAA;AAAA,IACA,KAAA;AAAA,IACA;AAAA,GACF;AAGA,EAAA,MAAM,aAAA,GAAgB,MAAM,UAAA,CAAW,cAAA,CAAe,WAAW,WAAW,CAAA;AAC5E,EAAA,IAAI,CAAC,aAAA,EAAe;AAClB,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,mDAAA,EAAsD,oBAAoB,KAAK,CAAA,gEAAA;AAAA,KACjF;AAAA,EACF;AAGA,EAAA,MAAM,WAAA,GAAc,MAAM,UAAA,CAAW,cAAA,CAAe,gBAAgB,WAAW,CAAA;AAC/E,EAAA,IAAI,CAAC,WAAA,EAAa;AAChB,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,0DAAA,EAA6D,oBAAoB,KAAK,CAAA,yEAAA;AAAA,KACxF;AAAA,EACF;AAGA,EAAA,MAAM,MAAA,GAAS,MAAA,CAAO,mBAAA,CAAoB,iBAAiB,CAAA;AAE3D,EAAA,YAAA,CAAa,IAAA;AAAA,IACXC,yCAAA;AAAA,MACE,SAAA;AAAA,MACA,UAAA;AAAA,MACA,cAAA;AAAA,MACA,UAAA;AAAA,MACA,MAAA;AAAA,MACA,IAAA,CAAK,QAAA;AAAA,MACL,EAAC;AAAA,MACD;AAAA;AACF,GACF;AAGA,EAAA,MAAM,EAAE,SAAA,EAAU,GAAI,MAAM,UAAA,CAAW,mBAAmB,WAAW,CAAA;AAErE,EAAA,MAAM,OAAA,GAAU,IAAIC,0BAAA,CAAmB;AAAA,IACrC,QAAA,EAAU,cAAA;AAAA,IACV,eAAA,EAAiB,SAAA;AAAA,IACjB;AAAA,GACD,EAAE,kBAAA,EAAmB;AAGtB,EAAA,MAAM,WAAA,GAAc,IAAIC,4BAAA,CAAqB,OAAO,CAAA;AAGpD,EAAA,IAAI,OAAO,MAAA,EAAQ,eAAA,KAAoB,UAAA,EAAY;AACjD,IAAA,MAAM,IAAI,MAAM,mDAAmD,CAAA;AAAA,EACrE;AAEA,EAAA,MAAM,YAAA,GAAe,MAAM,MAAA,CAAO,eAAA,CAAgB,WAAW,CAAA;AAE7D,EAAA,OAAO,kCAAA;AAAA,IACL,YAAA;AAAA,IACA,mBAAA;AAAA,IACA;AAAA,GACF;AACF;;;AC/IO,SAAS,mBACd,OAAA,EACA,MAAA,EACA,QACA,QAAA,GAAmB,MAAA,CAAO,CAAC,CAAA,EAC3B;AACA,EAAA,OAAO,OAAO,OAAoB,IAAA,KAA0C;AAE1E,IAAA,MAAM,QAAA,GAAW,MAAM,OAAA,CAAQ,KAAA,EAAO,IAAI,CAAA;AAG1C,IAAA,IAAI,QAAA,CAAS,WAAW,GAAA,EAAK;AAC3B,MAAA,OAAO,QAAA;AAAA,IACT;AAGA,IAAA,MAAM,WAAA,GAAc,MAAM,QAAA,CAAS,IAAA,EAAK;AAExC,IAAA,MAAM,cAAsB,WAAA,CAAY,WAAA;AACxC,IAAA,MAAM,yBAAA,GAAmD,WAAA,CAAY,OAAA,IAAW,EAAC;AAGjF,IAAA,MAAM,uBAAuB,yBAAA,CAA0B,IAAA;AAAA,MACrD,CAAC,QACC,GAAA,CAAI,MAAA,KAAW,YACd,GAAA,CAAI,OAAA,KAAY,eAAA,IAAmB,GAAA,CAAI,OAAA,KAAY,QAAA;AAAA,KACxD;AAEA,IAAA,IAAI,CAAC,oBAAA,EAAsB;AACzB,MAAA,OAAA,CAAQ,KAAA;AAAA,QACN,2EAAA;AAAA,QACA,yBAAA,CAA0B,GAAA,CAAI,CAAC,GAAA,KAAQ,IAAI,OAAO;AAAA,OACpD;AACA,MAAA,MAAM,IAAI,MAAM,+CAA+C,CAAA;AAAA,IACjE;AAGA,IAAA,IAAI,QAAA,GAAW,OAAO,CAAC,CAAA,IAAK,OAAO,oBAAA,CAAqB,iBAAiB,IAAI,QAAA,EAAU;AACrF,MAAA,MAAM,IAAI,MAAM,wCAAwC,CAAA;AAAA,IAC1D;AAGA,IAAA,MAAM,gBAAgB,MAAM,yBAAA;AAAA,MAC1B,MAAA;AAAA,MACA,WAAA;AAAA,MACA,oBAAA;AAAA,MACA;AAAA,KACF;AAGA,IAAA,MAAM,OAAA,GAAU;AAAA,MACd,GAAG,IAAA;AAAA,MACH,OAAA,EAAS;AAAA,QACP,GAAI,IAAA,EAAM,OAAA,IAAW,EAAC;AAAA,QACtB,WAAA,EAAa,aAAA;AAAA,QACb,+BAAA,EAAiC;AAAA;AACnC,KACF;AAEA,IAAA,OAAO,MAAM,OAAA,CAAQ,KAAA,EAAO,OAAO,CAAA;AAAA,EACrC,CAAA;AACF;;;AC1DO,IAAM,aAAN,MAAiB;AAAA,EACd,YAAA;AAAA,EAER,YAAY,MAAA,EAA0B;AACpC,IAAA,MAAM,MAAA,GAAS,MAAA,CAAO,MAAA,IAAU,gBAAA,CAAiB,OAAO,OAAO,CAAA;AAI/D,IAAA,MAAM,UAAU,MAAA,CAAO,WAAA,IAAe,UAAA,CAAW,KAAA,CAAM,KAAK,UAAU,CAAA;AAEtE,IAAA,IAAA,CAAK,YAAA,GAAe,kBAAA;AAAA,MAClB,OAAA;AAAA,MACA,MAAA,CAAO,MAAA;AAAA,MACP,MAAA;AAAA,MACA,MAAA,CAAO,gBAAA,IAAoB,MAAA,CAAO,CAAC;AAAA,KACrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,KAAA,CAAM,KAAA,EAAoB,IAAA,EAAuC;AACrE,IAAA,OAAO,IAAA,CAAK,YAAA,CAAa,KAAA,EAAO,IAAI,CAAA;AAAA,EACtC;AACF;AAKO,SAAS,iBAAiB,MAAA,EAAsC;AACrE,EAAA,OAAO,IAAI,WAAW,MAAM,CAAA;AAC9B","file":"index.js","sourcesContent":["import { VersionedTransaction } from \"@solana/web3.js\";\nimport { PaymentRequirements, SolanaNetwork, SPLTokenAmount } from \"../types\";\n\n/**\n * Helper utilities for x402 payment processing\n */\n\n/**\n * Create payment header from a signed transaction\n * Encodes transaction and payment details into base64 X-PAYMENT header\n */\nexport function createPaymentHeaderFromTransaction(\n  transaction: VersionedTransaction,\n  paymentRequirements: PaymentRequirements,\n  x402Version: number\n): string {\n  // Serialize the signed transaction\n  const serializedTransaction = Buffer.from(transaction.serialize()).toString(\"base64\");\n\n  // Create payment payload matching x402 spec\n  const paymentPayload = {\n    x402Version: x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      transaction: serializedTransaction,\n    },\n  };\n\n  // Encode payment payload as base64 for X-PAYMENT header\n  const paymentHeader = Buffer.from(JSON.stringify(paymentPayload)).toString(\"base64\");\n\n  return paymentHeader;\n}\n\n/**\n * Get default RPC URL for a given Solana network\n * @param network - Must be 'solana' or 'solana-devnet'\n * @returns Default RPC URL for the network\n */\nexport function getDefaultRpcUrl(network: SolanaNetwork): string {\n  if (network === \"solana\") {\n    return \"https://api.mainnet-beta.solana.com\";\n  } else if (network === \"solana-devnet\") {\n    return \"https://api.devnet.solana.com\";\n  }\n  // TypeScript ensures network is one of the two options, so this is unreachable\n  throw new Error(`Unexpected network: ${network}`);\n}\n\n/**\n * Get default SPL token asset for a given Solana network\n * Defaults to USDC, returns x402-compatible SPLTokenAmount['asset']\n */\nexport function getDefaultTokenAsset(network: SolanaNetwork): SPLTokenAmount['asset'] {\n  if (network === \"solana\") {\n    return {\n      address: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n      decimals: 6,\n    };\n  } else if (network === \"solana-devnet\") {\n    return {\n      address: \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\",\n      decimals: 6,\n    };\n  }\n  // TypeScript ensures network is one of the two options, so this is unreachable\n  throw new Error(`Unexpected network: ${network}`);\n}\n\n/**\n * Convert human-readable amount to token's smallest unit (atomic units)\n * @param amount - Human-readable amount (e.g., 2.5 for 2.5 USDC)\n * @param decimals - Token decimals (e.g., 6 for USDC, 9 for SOL)\n */\nexport function toAtomicUnits(amount: number, decimals: number): bigint {\n  return BigInt(Math.floor(amount * Math.pow(10, decimals)));\n}\n\n/**\n * Convert token's atomic units to human-readable amount\n * @param atomicUnits - Token amount in smallest units\n * @param decimals - Token decimals (e.g., 6 for USDC, 9 for SOL)\n */\nexport function fromAtomicUnits(atomicUnits: bigint | number, decimals: number): number {\n  return Number(atomicUnits) / Math.pow(10, decimals);\n}\n\n// Legacy USDC-specific helpers (deprecated, use toAtomicUnits/fromAtomicUnits instead)\n/** @deprecated Use toAtomicUnits(amount, 6) instead */\nexport function usdToMicroUsdc(usdAmount: number): number {\n  return Math.floor(usdAmount * 1_000_000);\n}\n\n/** @deprecated Use fromAtomicUnits(microUsdc, 6) instead */\nexport function microUsdcToUsd(microUsdc: number): number {\n  return microUsdc / 1_000_000;\n}\n\n","import {\n  PublicKey,\n  Connection,\n  TransactionMessage,\n  VersionedTransaction,\n  ComputeBudgetProgram,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  getAssociatedTokenAddress,\n  createTransferCheckedInstruction,\n  getMint,\n  TOKEN_PROGRAM_ID,\n  TOKEN_2022_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { PaymentRequirements, WalletAdapter } from \"../types\";\nimport { createPaymentHeaderFromTransaction } from \"../utils\";\n\n/**\n * Build and sign a Solana transaction for x402 payment\n */\nexport async function createSolanaPaymentHeader(\n  wallet: WalletAdapter,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n  rpcUrl: string\n): Promise<string> {\n  const connection = new Connection(rpcUrl, \"confirmed\");\n\n  // Extract fee payer from payment requirements\n  const feePayer = (paymentRequirements as { extra?: { feePayer?: string } })?.extra?.feePayer;\n  if (typeof feePayer !== \"string\" || !feePayer) {\n    throw new Error(\"Missing facilitator feePayer in payment requirements (extra.feePayer).\");\n  }\n  const feePayerPubkey = new PublicKey(feePayer);\n\n  // Support both Anza wallet-adapter (publicKey) and custom implementations (address)\n  const walletAddress = wallet?.publicKey?.toString() || wallet?.address;\n  if (!walletAddress) {\n    throw new Error(\"Missing connected Solana wallet address or publicKey\");\n  }\n  const userPubkey = new PublicKey(walletAddress);\n\n  if (!paymentRequirements?.payTo) {\n    throw new Error(\"Missing payTo in payment requirements\");\n  }\n  const destination = new PublicKey(paymentRequirements.payTo);\n\n  const instructions: TransactionInstruction[] = [];\n\n  // The facilitator REQUIRES ComputeBudget instructions in positions 0 and 1\n  instructions.push(\n    ComputeBudgetProgram.setComputeUnitLimit({\n      units: 7_000, // Sufficient for SPL token transfer\n    })\n  );\n\n  instructions.push(\n    ComputeBudgetProgram.setComputeUnitPrice({\n      microLamports: 1, // Minimal price\n    })\n  );\n\n  // SPL token or Token-2022\n  if (!paymentRequirements.asset) {\n    throw new Error(\"Missing token mint for SPL transfer\");\n  }\n  const mintPubkey = new PublicKey(paymentRequirements.asset as string);\n\n  // Determine program (token vs token-2022) by reading mint owner\n  const mintInfo = await connection.getAccountInfo(mintPubkey, \"confirmed\");\n  const programId =\n    mintInfo?.owner?.toBase58() === TOKEN_2022_PROGRAM_ID.toBase58()\n      ? TOKEN_2022_PROGRAM_ID\n      : TOKEN_PROGRAM_ID;\n\n  // Fetch mint to get decimals\n  const mint = await getMint(connection, mintPubkey, undefined, programId);\n\n  // Derive source and destination ATAs\n  const sourceAta = await getAssociatedTokenAddress(\n    mintPubkey,\n    userPubkey,\n    false,\n    programId\n  );\n  const destinationAta = await getAssociatedTokenAddress(\n    mintPubkey,\n    destination,\n    false,\n    programId\n  );\n\n  // Check if source ATA exists (user must already have token account)\n  const sourceAtaInfo = await connection.getAccountInfo(sourceAta, \"confirmed\");\n  if (!sourceAtaInfo) {\n    throw new Error(\n      `User does not have an Associated Token Account for ${paymentRequirements.asset}. Please create one first or ensure you have the required token.`\n    );\n  }\n\n  // Check if destination ATA exists (receiver must already have token account)\n  const destAtaInfo = await connection.getAccountInfo(destinationAta, \"confirmed\");\n  if (!destAtaInfo) {\n    throw new Error(\n      `Destination does not have an Associated Token Account for ${paymentRequirements.asset}. The receiver must create their token account before receiving payments.`\n    );\n  }\n\n  // TransferChecked instruction\n  const amount = BigInt(paymentRequirements.maxAmountRequired);\n\n  instructions.push(\n    createTransferCheckedInstruction(\n      sourceAta,\n      mintPubkey,\n      destinationAta,\n      userPubkey,\n      amount,\n      mint.decimals,\n      [],\n      programId\n    )\n  );\n\n  // Get recent blockhash\n  const { blockhash } = await connection.getLatestBlockhash(\"confirmed\");\n\n  const message = new TransactionMessage({\n    payerKey: feePayerPubkey,\n    recentBlockhash: blockhash,\n    instructions,\n  }).compileToV0Message();\n\n  // Create transaction\n  const transaction = new VersionedTransaction(message);\n\n  // Sign with user's wallet\n  if (typeof wallet?.signTransaction !== \"function\") {\n    throw new Error(\"Connected wallet does not support signTransaction\");\n  }\n\n  const userSignedTx = await wallet.signTransaction(transaction);\n\n  return createPaymentHeaderFromTransaction(\n    userSignedTx,\n    paymentRequirements,\n    x402Version\n  );\n}\n\n","import { PaymentRequirements, x402Response, WalletAdapter } from \"../types\";\nimport { createSolanaPaymentHeader } from \"./transaction-builder\";\n\n/**\n * Create a custom fetch function that automatically handles x402 payments\n */\nexport function createPaymentFetch(\n  fetchFn: typeof fetch,\n  wallet: WalletAdapter,\n  rpcUrl: string,\n  maxValue: bigint = BigInt(0)\n) {\n  return async (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // Make initial request\n    const response = await fetchFn(input, init);\n\n    // If not 402, return as-is\n    if (response.status !== 402) {\n      return response;\n    }\n\n    // Parse payment requirements from 402 response\n    const rawResponse = await response.json() as x402Response;\n\n    const x402Version: number = rawResponse.x402Version;\n    const parsedPaymentRequirements: PaymentRequirements[] = rawResponse.accepts || [];\n\n    // Select first suitable payment requirement for Solana\n    const selectedRequirements = parsedPaymentRequirements.find(\n      (req: PaymentRequirements) =>\n        req.scheme === \"exact\" &&\n        (req.network === \"solana-devnet\" || req.network === \"solana\")\n    );\n\n    if (!selectedRequirements) {\n      console.error(\n        \"âŒ No suitable Solana payment requirements found. Available networks:\",\n        parsedPaymentRequirements.map((req) => req.network)\n      );\n      throw new Error(\"No suitable Solana payment requirements found\");\n    }\n\n    // Check amount against max value if specified\n    if (maxValue > BigInt(0) && BigInt(selectedRequirements.maxAmountRequired) > maxValue) {\n      throw new Error(\"Payment amount exceeds maximum allowed\");\n    }\n\n    // Create payment header using Solana transaction builder\n    const paymentHeader = await createSolanaPaymentHeader(\n      wallet,\n      x402Version,\n      selectedRequirements,\n      rpcUrl\n    );\n\n    // Retry with payment header\n    const newInit = {\n      ...init,\n      headers: {\n        ...(init?.headers || {}),\n        \"X-PAYMENT\": paymentHeader,\n        \"Access-Control-Expose-Headers\": \"X-PAYMENT-RESPONSE\",\n      },\n    };\n\n    return await fetchFn(input, newInit);\n  };\n}\n\n","import { X402ClientConfig } from \"../types\";\nimport { getDefaultRpcUrl } from \"../utils\";\nimport { createPaymentFetch } from \"./payment-interceptor\";\n\n/**\n * x402 Solana Client\n * Handles automatic payment for x402-protected endpoints\n */\n\nexport class X402Client {\n  private paymentFetch: ReturnType<typeof createPaymentFetch>;\n\n  constructor(config: X402ClientConfig) {\n    const rpcUrl = config.rpcUrl || getDefaultRpcUrl(config.network);\n\n    // Use custom fetch if provided, otherwise use native fetch\n    // globalThis.fetch works in both browser and Node.js (18+)\n    const fetchFn = config.customFetch || globalThis.fetch.bind(globalThis);\n\n    this.paymentFetch = createPaymentFetch(\n      fetchFn,\n      config.wallet,\n      rpcUrl,\n      config.maxPaymentAmount || BigInt(0)\n    );\n  }\n\n  /**\n   * Make a fetch request with automatic x402 payment handling.\n   * If a customFetch was provided in the config, it will be used for all requests.\n   */\n  async fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n    return this.paymentFetch(input, init);\n  }\n}\n\n/**\n * Create an x402 client instance\n */\nexport function createX402Client(config: X402ClientConfig): X402Client {\n  return new X402Client(config);\n}\n\n// Re-export types for convenience\nexport type { X402ClientConfig, WalletAdapter } from \"../types\";\n\n"]}