'use strict';

var web3_js = require('@solana/web3.js');
var splToken = require('@solana/spl-token');

// src/utils/helpers.ts
function createPaymentHeaderFromTransaction(transaction, paymentRequirements, x402Version) {
  const serializedTransaction = Buffer.from(transaction.serialize()).toString("base64");
  const paymentPayload = {
    x402Version,
    scheme: paymentRequirements.scheme,
    network: paymentRequirements.network,
    payload: {
      transaction: serializedTransaction
    }
  };
  const paymentHeader = Buffer.from(JSON.stringify(paymentPayload)).toString("base64");
  return paymentHeader;
}
function getDefaultRpcUrl(network) {
  if (network === "solana") {
    return "https://api.mainnet-beta.solana.com";
  } else if (network === "solana-devnet") {
    return "https://api.devnet.solana.com";
  }
  throw new Error(`Unexpected network: ${network}`);
}
async function createSolanaPaymentHeader(wallet, x402Version, paymentRequirements, rpcUrl) {
  const connection = new web3_js.Connection(rpcUrl, "confirmed");
  const feePayer = paymentRequirements?.extra?.feePayer;
  if (typeof feePayer !== "string" || !feePayer) {
    throw new Error("Missing facilitator feePayer in payment requirements (extra.feePayer).");
  }
  const feePayerPubkey = new web3_js.PublicKey(feePayer);
  const walletAddress = wallet?.publicKey?.toString() || wallet?.address;
  if (!walletAddress) {
    throw new Error("Missing connected Solana wallet address or publicKey");
  }
  const userPubkey = new web3_js.PublicKey(walletAddress);
  if (!paymentRequirements?.payTo) {
    throw new Error("Missing payTo in payment requirements");
  }
  const destination = new web3_js.PublicKey(paymentRequirements.payTo);
  const instructions = [];
  instructions.push(
    web3_js.ComputeBudgetProgram.setComputeUnitLimit({
      units: 7e3
      // Sufficient for SPL token transfer
    })
  );
  instructions.push(
    web3_js.ComputeBudgetProgram.setComputeUnitPrice({
      microLamports: 1
      // Minimal price
    })
  );
  if (!paymentRequirements.asset) {
    throw new Error("Missing token mint for SPL transfer");
  }
  const mintPubkey = new web3_js.PublicKey(paymentRequirements.asset);
  const mintInfo = await connection.getAccountInfo(mintPubkey, "confirmed");
  const programId = mintInfo?.owner?.toBase58() === splToken.TOKEN_2022_PROGRAM_ID.toBase58() ? splToken.TOKEN_2022_PROGRAM_ID : splToken.TOKEN_PROGRAM_ID;
  const mint = await splToken.getMint(connection, mintPubkey, void 0, programId);
  const sourceAta = await splToken.getAssociatedTokenAddress(
    mintPubkey,
    userPubkey,
    false,
    programId
  );
  const destinationAta = await splToken.getAssociatedTokenAddress(
    mintPubkey,
    destination,
    false,
    programId
  );
  const sourceAtaInfo = await connection.getAccountInfo(sourceAta, "confirmed");
  if (!sourceAtaInfo) {
    throw new Error(
      `User does not have an Associated Token Account for ${paymentRequirements.asset}. Please create one first or ensure you have the required token.`
    );
  }
  const destAtaInfo = await connection.getAccountInfo(destinationAta, "confirmed");
  if (!destAtaInfo) {
    throw new Error(
      `Destination does not have an Associated Token Account for ${paymentRequirements.asset}. The receiver must create their token account before receiving payments.`
    );
  }
  const amount = BigInt(paymentRequirements.maxAmountRequired);
  instructions.push(
    splToken.createTransferCheckedInstruction(
      sourceAta,
      mintPubkey,
      destinationAta,
      userPubkey,
      amount,
      mint.decimals,
      [],
      programId
    )
  );
  const { blockhash } = await connection.getLatestBlockhash("confirmed");
  const message = new web3_js.TransactionMessage({
    payerKey: feePayerPubkey,
    recentBlockhash: blockhash,
    instructions
  }).compileToV0Message();
  const transaction = new web3_js.VersionedTransaction(message);
  if (typeof wallet?.signTransaction !== "function") {
    throw new Error("Connected wallet does not support signTransaction");
  }
  const userSignedTx = await wallet.signTransaction(transaction);
  return createPaymentHeaderFromTransaction(
    userSignedTx,
    paymentRequirements,
    x402Version
  );
}

// src/client/payment-interceptor.ts
function createPaymentFetch(fetchFn, wallet, rpcUrl, maxValue = BigInt(0)) {
  return async (input, init) => {
    const response = await fetchFn(input, init);
    if (response.status !== 402) {
      return response;
    }
    const rawResponse = await response.json();
    const x402Version = rawResponse.x402Version;
    const parsedPaymentRequirements = rawResponse.accepts || [];
    const selectedRequirements = parsedPaymentRequirements.find(
      (req) => req.scheme === "exact" && (req.network === "solana-devnet" || req.network === "solana")
    );
    if (!selectedRequirements) {
      console.error(
        "\u274C No suitable Solana payment requirements found. Available networks:",
        parsedPaymentRequirements.map((req) => req.network)
      );
      throw new Error("No suitable Solana payment requirements found");
    }
    if (maxValue > BigInt(0) && BigInt(selectedRequirements.maxAmountRequired) > maxValue) {
      throw new Error("Payment amount exceeds maximum allowed");
    }
    const paymentHeader = await createSolanaPaymentHeader(
      wallet,
      x402Version,
      selectedRequirements,
      rpcUrl
    );
    const newInit = {
      ...init,
      headers: {
        ...init?.headers || {},
        "X-PAYMENT": paymentHeader,
        "Access-Control-Expose-Headers": "X-PAYMENT-RESPONSE"
      }
    };
    return await fetchFn(input, newInit);
  };
}

// src/client/index.ts
var X402Client = class {
  paymentFetch;
  constructor(config) {
    const rpcUrl = config.rpcUrl || getDefaultRpcUrl(config.network);
    const fetchFn = config.customFetch || globalThis.fetch.bind(globalThis);
    this.paymentFetch = createPaymentFetch(
      fetchFn,
      config.wallet,
      rpcUrl,
      config.maxPaymentAmount || BigInt(0)
    );
  }
  /**
   * Make a fetch request with automatic x402 payment handling.
   * If a customFetch was provided in the config, it will be used for all requests.
   */
  async fetch(input, init) {
    return this.paymentFetch(input, init);
  }
};
function createX402Client(config) {
  return new X402Client(config);
}

exports.X402Client = X402Client;
exports.createX402Client = createX402Client;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map